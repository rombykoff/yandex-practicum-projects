# Исследование надежности заемщиков


Во второй части проекта вы выполните шаги 3 и 4. Их вручную проверит ревьюер.
Чтобы вам не пришлось писать код заново для шагов 1 и 2, мы добавили авторские решения в ячейки с кодом. 



## Откройте таблицу и изучите общую информацию о данных

**Задание 1. Импортируйте библиотеку pandas. Считайте данные из csv-файла в датафрейм и сохраните в переменную `data`. Путь к файлу:**

`/datasets/data.csv`


```python
import pandas as pd

try:
    data = pd.read_csv('/datasets/data.csv')
except:
    data = pd.read_csv('https://code.s3.yandex.net/datasets/data.csv')
```

**Задание 2. Выведите первые 20 строчек датафрейма `data` на экран.**


```python
data.head(20)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>children</th>
      <th>days_employed</th>
      <th>dob_years</th>
      <th>education</th>
      <th>education_id</th>
      <th>family_status</th>
      <th>family_status_id</th>
      <th>gender</th>
      <th>income_type</th>
      <th>debt</th>
      <th>total_income</th>
      <th>purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>-8437.673028</td>
      <td>42</td>
      <td>высшее</td>
      <td>0</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>253875.639453</td>
      <td>покупка жилья</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>-4024.803754</td>
      <td>36</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>112080.014102</td>
      <td>приобретение автомобиля</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>-5623.422610</td>
      <td>33</td>
      <td>Среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>M</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>145885.952297</td>
      <td>покупка жилья</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>-4124.747207</td>
      <td>32</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>M</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>267628.550329</td>
      <td>дополнительное образование</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>340266.072047</td>
      <td>53</td>
      <td>среднее</td>
      <td>1</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>F</td>
      <td>пенсионер</td>
      <td>0</td>
      <td>158616.077870</td>
      <td>сыграть свадьбу</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>-926.185831</td>
      <td>27</td>
      <td>высшее</td>
      <td>0</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>M</td>
      <td>компаньон</td>
      <td>0</td>
      <td>255763.565419</td>
      <td>покупка жилья</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0</td>
      <td>-2879.202052</td>
      <td>43</td>
      <td>высшее</td>
      <td>0</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>компаньон</td>
      <td>0</td>
      <td>240525.971920</td>
      <td>операции с жильем</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>-152.779569</td>
      <td>50</td>
      <td>СРЕДНЕЕ</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>M</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>135823.934197</td>
      <td>образование</td>
    </tr>
    <tr>
      <th>8</th>
      <td>2</td>
      <td>-6929.865299</td>
      <td>35</td>
      <td>ВЫСШЕЕ</td>
      <td>0</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>95856.832424</td>
      <td>на проведение свадьбы</td>
    </tr>
    <tr>
      <th>9</th>
      <td>0</td>
      <td>-2188.756445</td>
      <td>41</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>M</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>144425.938277</td>
      <td>покупка жилья для семьи</td>
    </tr>
    <tr>
      <th>10</th>
      <td>2</td>
      <td>-4171.483647</td>
      <td>36</td>
      <td>высшее</td>
      <td>0</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>M</td>
      <td>компаньон</td>
      <td>0</td>
      <td>113943.491460</td>
      <td>покупка недвижимости</td>
    </tr>
    <tr>
      <th>11</th>
      <td>0</td>
      <td>-792.701887</td>
      <td>40</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>77069.234271</td>
      <td>покупка коммерческой недвижимости</td>
    </tr>
    <tr>
      <th>12</th>
      <td>0</td>
      <td>NaN</td>
      <td>65</td>
      <td>среднее</td>
      <td>1</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>M</td>
      <td>пенсионер</td>
      <td>0</td>
      <td>NaN</td>
      <td>сыграть свадьбу</td>
    </tr>
    <tr>
      <th>13</th>
      <td>0</td>
      <td>-1846.641941</td>
      <td>54</td>
      <td>неоконченное высшее</td>
      <td>2</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>130458.228857</td>
      <td>приобретение автомобиля</td>
    </tr>
    <tr>
      <th>14</th>
      <td>0</td>
      <td>-1844.956182</td>
      <td>56</td>
      <td>высшее</td>
      <td>0</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>F</td>
      <td>компаньон</td>
      <td>1</td>
      <td>165127.911772</td>
      <td>покупка жилой недвижимости</td>
    </tr>
    <tr>
      <th>15</th>
      <td>1</td>
      <td>-972.364419</td>
      <td>26</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>116820.904450</td>
      <td>строительство собственной недвижимости</td>
    </tr>
    <tr>
      <th>16</th>
      <td>0</td>
      <td>-1719.934226</td>
      <td>35</td>
      <td>среднее</td>
      <td>1</td>
      <td>женат / замужем</td>
      <td>0</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>289202.704229</td>
      <td>недвижимость</td>
    </tr>
    <tr>
      <th>17</th>
      <td>0</td>
      <td>-2369.999720</td>
      <td>33</td>
      <td>высшее</td>
      <td>0</td>
      <td>гражданский брак</td>
      <td>1</td>
      <td>M</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>90410.586745</td>
      <td>строительство недвижимости</td>
    </tr>
    <tr>
      <th>18</th>
      <td>0</td>
      <td>400281.136913</td>
      <td>53</td>
      <td>среднее</td>
      <td>1</td>
      <td>вдовец / вдова</td>
      <td>2</td>
      <td>F</td>
      <td>пенсионер</td>
      <td>0</td>
      <td>56823.777243</td>
      <td>на покупку подержанного автомобиля</td>
    </tr>
    <tr>
      <th>19</th>
      <td>0</td>
      <td>-10038.818549</td>
      <td>48</td>
      <td>СРЕДНЕЕ</td>
      <td>1</td>
      <td>в разводе</td>
      <td>3</td>
      <td>F</td>
      <td>сотрудник</td>
      <td>0</td>
      <td>242831.107982</td>
      <td>на покупку своего автомобиля</td>
    </tr>
  </tbody>
</table>
</div>



**Задание 3. Выведите основную информацию о датафрейме с помощью метода `info()`.**


```python
data.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 21525 entries, 0 to 21524
    Data columns (total 12 columns):
     #   Column            Non-Null Count  Dtype  
    ---  ------            --------------  -----  
     0   children          21525 non-null  int64  
     1   days_employed     19351 non-null  float64
     2   dob_years         21525 non-null  int64  
     3   education         21525 non-null  object 
     4   education_id      21525 non-null  int64  
     5   family_status     21525 non-null  object 
     6   family_status_id  21525 non-null  int64  
     7   gender            21525 non-null  object 
     8   income_type       21525 non-null  object 
     9   debt              21525 non-null  int64  
     10  total_income      19351 non-null  float64
     11  purpose           21525 non-null  object 
    dtypes: float64(2), int64(5), object(5)
    memory usage: 2.0+ MB


## Предобработка данных

### Удаление пропусков

**Задание 4. Выведите количество пропущенных значений для каждого столбца. Используйте комбинацию двух методов.**


```python
data.isna().sum()
```




    children               0
    days_employed       2174
    dob_years              0
    education              0
    education_id           0
    family_status          0
    family_status_id       0
    gender                 0
    income_type            0
    debt                   0
    total_income        2174
    purpose                0
    dtype: int64



**Задание 5. В двух столбцах есть пропущенные значения. Один из них — `days_employed`. Пропуски в этом столбце вы обработаете на следующем этапе. Другой столбец с пропущенными значениями — `total_income` — хранит данные о доходах. На сумму дохода сильнее всего влияет тип занятости, поэтому заполнить пропуски в этом столбце нужно медианным значением по каждому типу из столбца `income_type`. Например, у человека с типом занятости `сотрудник` пропуск в столбце `total_income` должен быть заполнен медианным доходом среди всех записей с тем же типом.**


```python
for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['total_income'].isna()), 'total_income'] = \
    data.loc[(data['income_type'] == t), 'total_income'].median()
```

### Обработка аномальных значений

**Задание 6. В данных могут встречаться артефакты (аномалии) — значения, которые не отражают действительность и появились по какой-то ошибке. таким артефактом будет отрицательное количество дней трудового стажа в столбце `days_employed`. Для реальных данных это нормально. Обработайте значения в этом столбце: замените все отрицательные значения положительными с помощью метода `abs()`.**


```python
data['days_employed'] = data['days_employed'].abs()
```

**Задание 7. Для каждого типа занятости выведите медианное значение трудового стажа `days_employed` в днях.**


```python
data.groupby('income_type')['days_employed'].agg('median')
```




    income_type
    безработный        366413.652744
    в декрете            3296.759962
    госслужащий          2689.368353
    компаньон            1547.382223
    пенсионер          365213.306266
    предприниматель       520.848083
    сотрудник            1574.202821
    студент               578.751554
    Name: days_employed, dtype: float64



У двух типов (безработные и пенсионеры) получатся аномально большие значения. Исправить такие значения сложно, поэтому оставьте их как есть. Тем более этот столбец не понадобится вам для исследования.

**Задание 8. Выведите перечень уникальных значений столбца `children`.**


```python
data['children'].unique()
```




    array([ 1,  0,  3,  2, -1,  4, 20,  5])



**Задание 9. В столбце `children` есть два аномальных значения. Удалите строки, в которых встречаются такие аномальные значения из датафрейма `data`.**


```python
data = data[(data['children'] != -1) & (data['children'] != 20)]
```

**Задание 10. Ещё раз выведите перечень уникальных значений столбца `children`, чтобы убедиться, что артефакты удалены.**


```python
data['children'].unique()
```




    array([1, 0, 3, 2, 4, 5])



### Удаление пропусков (продолжение)

**Задание 11. Заполните пропуски в столбце `days_employed` медианными значениями по каждого типа занятости `income_type`.**


```python
for t in data['income_type'].unique():
    data.loc[(data['income_type'] == t) & (data['days_employed'].isna()), 'days_employed'] = \
    data.loc[(data['income_type'] == t), 'days_employed'].median()
```

**Задание 12. Убедитесь, что все пропуски заполнены. Проверьте себя и ещё раз выведите количество пропущенных значений для каждого столбца с помощью двух методов.**


```python
data.isna().sum()
```




    children            0
    days_employed       0
    dob_years           0
    education           0
    education_id        0
    family_status       0
    family_status_id    0
    gender              0
    income_type         0
    debt                0
    total_income        0
    purpose             0
    dtype: int64



### Изменение типов данных

**Задание 13. Замените вещественный тип данных в столбце `total_income` на целочисленный с помощью метода `astype()`.**


```python
data['total_income'] = data['total_income'].astype(int)
```

### Обработка дубликатов

**Задание 14. Выведите на экран количество строк-дубликатов в данных. Если такие строки присутствуют, удалите их.**


```python
data.duplicated().sum()
```




    54




```python
data = data.drop_duplicates()
```

**Задание 15. Обработайте неявные дубликаты в столбце `education`. В этом столбце есть одни и те же значения, но записанные по-разному: с использованием заглавных и строчных букв. Приведите их к нижнему регистру. Проверьте остальные столбцы.**


```python
data['education'] = data['education'].str.lower()
```

### Категоризация данных

**Задание 16. На основании диапазонов, указанных ниже, создайте в датафрейме `data` столбец `total_income_category` с категориями:**

- 0–30000 — `'E'`;
- 30001–50000 — `'D'`;
- 50001–200000 — `'C'`;
- 200001–1000000 — `'B'`;
- 1000001 и выше — `'A'`.


**Например, кредитополучателю с доходом 25000 нужно назначить категорию `'E'`, а клиенту, получающему 235000, — `'B'`. Используйте собственную функцию с именем `categorize_income()` и метод `apply()`.**


```python
def categorize_income(income):
    try:
        if 0 <= income <= 30000:
            return 'E'
        elif 30001 <= income <= 50000:
            return 'D'
        elif 50001 <= income <= 200000:
            return 'C'
        elif 200001 <= income <= 1000000:
            return 'B'
        elif income >= 1000001:
            return 'A'
    except:
        pass
```


```python
data['total_income_category'] = data['total_income'].apply(categorize_income)
```

**Задание 17. Выведите на экран перечень уникальных целей взятия кредита из столбца `purpose`.**


```python
data['purpose'].unique()
```




    array(['покупка жилья', 'приобретение автомобиля',
           'дополнительное образование', 'сыграть свадьбу',
           'операции с жильем', 'образование', 'на проведение свадьбы',
           'покупка жилья для семьи', 'покупка недвижимости',
           'покупка коммерческой недвижимости', 'покупка жилой недвижимости',
           'строительство собственной недвижимости', 'недвижимость',
           'строительство недвижимости', 'на покупку подержанного автомобиля',
           'на покупку своего автомобиля',
           'операции с коммерческой недвижимостью',
           'строительство жилой недвижимости', 'жилье',
           'операции со своей недвижимостью', 'автомобили',
           'заняться образованием', 'сделка с подержанным автомобилем',
           'получение образования', 'автомобиль', 'свадьба',
           'получение дополнительного образования', 'покупка своего жилья',
           'операции с недвижимостью', 'получение высшего образования',
           'свой автомобиль', 'сделка с автомобилем',
           'профильное образование', 'высшее образование',
           'покупка жилья для сдачи', 'на покупку автомобиля', 'ремонт жилью',
           'заняться высшим образованием'], dtype=object)



**Задание 18. Создайте функцию, которая на основании данных из столбца `purpose` сформирует новый столбец `purpose_category`, в который войдут следующие категории:**

- `'операции с автомобилем'`,
- `'операции с недвижимостью'`,
- `'проведение свадьбы'`,
- `'получение образования'`.

**Например, если в столбце `purpose` находится подстрока `'на покупку автомобиля'`, то в столбце `purpose_category` должна появиться строка `'операции с автомобилем'`.**

**Используйте собственную функцию с именем `categorize_purpose()` и метод `apply()`. Изучите данные в столбце `purpose` и определите, какие подстроки помогут вам правильно определить категорию.**


```python
def categorize_purpose(row):
    try:
        if 'автом' in row:
            return 'операции с автомобилем'
        elif 'жил' in row or 'недвиж' in row:
            return 'операции с недвижимостью'
        elif 'свад' in row:
            return 'проведение свадьбы'
        elif 'образов' in row:
            return 'получение образования'
    except:
        return 'нет категории'
```


```python
data['purpose_category'] = data['purpose'].apply(categorize_purpose)
```

## Исследуйте данные и ответьте на вопросы

**Задание 19. Есть ли зависимость между количеством детей и возвратом кредита в срок?**

Для ответа на данный вопрос разобьем заемщиков на группы по количеству детей. Посмотрим их колличество в каждой группе.


```python
children_count = data['children'].value_counts()
children_count
```




    0    14107
    1     4809
    2     2052
    3      330
    4       41
    5        9
    Name: children, dtype: int64



Отфильтруем заемщиков с просроченной задолжностью и посмотрим на их долю от общего числа в каждой группе.

Далее сравним значения "без детей" и "с детьми".


```python
print('Процент заемщиков с задолжностью по каждой группе:')
children_debt = data[data['debt'] == 1].groupby('children')['debt'].count()
display((children_debt / children_count) * 100)
print('Доля заемщиков с задолжностью по возврату кредита без детей:', (children_debt[0] / children_count[0]) * 100)
#исключим из выборки заемщиков без детей и посчитаем среднее значение
children_debt_sr = children_debt[1:]
children_count_sr = children_count[1:]
print('Среднее значение доли заемщиков с задолжностью и с детьми:', ((children_debt_sr / children_count_sr) * 100).mean())
```

    Процент заемщиков с задолжностью по каждой группе:



    0    7.535266
    1    9.232689
    2    9.454191
    3    8.181818
    4    9.756098
    5         NaN
    dtype: float64


    Доля заемщиков с задолжностью по возврату кредита без детей: 7.535266179910682
    Среднее значение доли заемщиков с задолжностью и с детьми: 9.156198871150858


**Вывод:** 

Из полученных данных мы видим, что факт наличия детей у заемщика увеличивает вероятность появления задолжности по возврату кредита примерно на 1.63%. 

Так же малое влиение имеет количестово детей у заемщика. Максимальная разница между группами составляет 1.57%.


```python
debt_pivot = data.pivot_table(index=['children'], columns='debt', values='gender', aggfunc='count', fill_value=0)
debt_pivot['sum'] = debt_pivot[0] + debt_pivot[1]
debt_pivot['ratio'] = debt_pivot[1] / debt_pivot['sum'] * 100
debt_pivot
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>debt</th>
      <th>0</th>
      <th>1</th>
      <th>sum</th>
      <th>ratio</th>
    </tr>
    <tr>
      <th>children</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>13044</td>
      <td>1063</td>
      <td>14107</td>
      <td>7.535266</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4365</td>
      <td>444</td>
      <td>4809</td>
      <td>9.232689</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1858</td>
      <td>194</td>
      <td>2052</td>
      <td>9.454191</td>
    </tr>
    <tr>
      <th>3</th>
      <td>303</td>
      <td>27</td>
      <td>330</td>
      <td>8.181818</td>
    </tr>
    <tr>
      <th>4</th>
      <td>37</td>
      <td>4</td>
      <td>41</td>
      <td>9.756098</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9</td>
      <td>0</td>
      <td>9</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
#код ревьюера
data.pivot_table(index=['children'], values='debt', aggfunc=['count', 'sum', 'mean'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>count</th>
      <th>sum</th>
      <th>mean</th>
    </tr>
    <tr>
      <th></th>
      <th>debt</th>
      <th>debt</th>
      <th>debt</th>
    </tr>
    <tr>
      <th>children</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>14107</td>
      <td>1063</td>
      <td>0.075353</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4809</td>
      <td>444</td>
      <td>0.092327</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2052</td>
      <td>194</td>
      <td>0.094542</td>
    </tr>
    <tr>
      <th>3</th>
      <td>330</td>
      <td>27</td>
      <td>0.081818</td>
    </tr>
    <tr>
      <th>4</th>
      <td>41</td>
      <td>4</td>
      <td>0.097561</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9</td>
      <td>0</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>



**Задание 20. Есть ли зависимость между семейным положением и возвратом кредита в срок?**

Для решения задачи, сначала посмотрим на уникальные значения в столбце `family_status`.


```python
data['family_status'].unique()
```




    array(['женат / замужем', 'гражданский брак', 'вдовец / вдова',
           'в разводе', 'Не женат / не замужем'], dtype=object)



Приведем столбец к нижнему регистру.


```python
data['family_status'] = data['family_status'].str.lower()
data['family_status'].unique()
```




    array(['женат / замужем', 'гражданский брак', 'вдовец / вдова',
           'в разводе', 'не женат / не замужем'], dtype=object)



Сгруппируем заемщиков по семейному положению и посчитаем их количество в каждой группе.


```python
status_group = data.groupby('family_status')['debt'].count()
status_group.sort_values()
```




    family_status
    вдовец / вдова             951
    в разводе                 1189
    не женат / не замужем     2796
    гражданский брак          4146
    женат / замужем          12266
    Name: debt, dtype: int64



Посчитаем процент заемщиков с задолжностью в каждой группе.


```python
status_group_deb = data[data['debt'] == 1].groupby('family_status')['debt'].count()
((status_group_deb / status_group) * 100).sort_values()
```




    family_status
    вдовец / вдова           6.624606
    в разводе                7.064760
    женат / замужем          7.557476
    гражданский брак         9.286059
    не женат / не замужем    9.763948
    Name: debt, dtype: float64



**Вывод:** 

Из полученных значений можем сделать вывод, что заемщики живущие в "гражданском браке" или "не женаты / не замужем" имеют большую вероятность получить задолженность по возврату кредита.

**Задание 21. Есть ли зависимость между уровнем дохода и возвратом кредита в срок?**

При изучении зависимости, начнем с группировки заемщиков по категориям дохода. Используем столбец `total_income_category`, который создали ранее.


```python
income_group = data.groupby('total_income_category')['debt'].count()
income_group
```




    total_income_category
    A       25
    B     5014
    C    15938
    D      349
    E       22
    Name: debt, dtype: int64



Посчитаем процент заемщиков с задолжностью от общего числа по каждой группе и сделаем выводы.


```python
income_group_deb = data[data['debt'] == 1].groupby('total_income_category')['debt'].count()
((income_group_deb / income_group) * 100).sort_values()
```




    total_income_category
    D    6.017192
    B    7.060231
    A    8.000000
    C    8.489145
    E    9.090909
    Name: debt, dtype: float64



**Вывод:** 

Вспомним категории дохода:
- 0–30000 — `'E'`;
- 30001–50000 — `'D'`;
- 50001–200000 — `'C'`;
- 200001–1000000 — `'B'`;
- 1000001 и выше — `'A'`.

Из полученных данных, мы можем сделать вывод, что чаще других допускают задолжность клиенты категории `E`, с доходом до 30000. Меньше всего `D`, с доходом до 50000. Клиенты с категорией дохода `A` и `C` допускают задолжность примерно одинаково.

**Задание 22. Как разные цели кредита влияют на его возврат в срок?**

Для начала сгруппируем заемщиков по целям кредита и посчитаем их количество:


```python
purpose_group = data.groupby('purpose_category')['debt'].count()
purpose_group.sort_values()
```




    purpose_category
    проведение свадьбы           2324
    получение образования        3989
    операции с автомобилем       4281
    операции с недвижимостью    10754
    Name: debt, dtype: int64



Посчитаем какая доля заемщиков в каждой группе допустила задолжность по кредиту:


```python
purpose_group_deb = data[data['debt'] == 1].groupby('purpose_category')['debt'].count()
((purpose_group_deb / purpose_group) * 100).sort_values()
```




    purpose_category
    операции с недвижимостью    7.253115
    проведение свадьбы          7.874355
    получение образования       9.250439
    операции с автомобилем      9.343611
    Name: debt, dtype: float64



Из полученных данных мы видим, что заемщики с целью кредита `операции с автомобилем` и `получение образования` чаще остальных допускают задолжность.

Большая вероятность появления задолжности в категории `операции с автомобилем` может быть связана с возникающими дополнительными расходами на  автомобиль (техническое обслуживание, обязательное страхование КАСКО и ОСАГО, покупка дополнительного комплекта резина и т.д.)

Для категории `получение образования` может быть связано с тем, что **бóльшая** часть заемщиков - это студенты ВУЗов, совмещающие учебу и работу с неполным рабочем днём. Имеющийся датафрейм позволит проверить нам версию:
"Медианный возраст заемщиков с задолжностью по кредиту для образования - до 25 лет включительно."

Возраст расчитан : 25 = 18(окончание школы) + 7(обучение в ВУЗе)

Проверим столбец с указанием возраста на ошибки с помощью уникальных значений.


```python
data['dob_years'].sort_values().unique()
```




    array([ 0, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
           35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
           52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
           69, 70, 71, 72, 73, 74, 75])



Посчитаем обнаруженые ошибочные значения с возрастом `0`


```python
j = data[data['dob_years'] == 0]['dob_years'].count()
print('Общее число заемщиков с возрастом "0":',j)
```

    Общее число заемщиков с возрастом "0": 100


Так как общее количество некорректных значений на фоне общего количества строк мало, отфильтруем ненужные строки.
Далее посмотрим на медианный возраст заемщиков с допущенной задолжностью в категории `получение образования`.


```python
age = data[data['dob_years'] != 0]
age = age[age['debt'] == 1] 
age_i = age[age['purpose_category'] == 'получение образования']
print('Медианный возраст заемщиков с задолжностью в категории "получение образования":', age_i['dob_years'].sort_values().median())
print('Медианный возраст всех заемщиков с задолжностью:', age['dob_years'].sort_values().median())
```

    Медианный возраст заемщиков с задолжностью в категории "получение образования": 38.0
    Медианный возраст всех заемщиков с задолжностью: 39.0


Версия не подтвердилась.

**Вывод:** 

Заемщики с целью кредита `операции с автомобилем` и `получение образования` чаще остальных допускают задолжность.

**Задание 23. Приведите возможные причины появления пропусков в исходных данных.**

*Ответ:* 

Пропуски в исходных данных могли возникнуть как в следствии технологических ошибок(некорректная выгрузка), так и в следствии человеческого фактора(пропуски при заполнении данных, опечатки, ошибки при переносе данных)

**Задание 24. Объясните, почему заполнить пропуски медианным значением — лучшее решение для количественных переменных.**

*Ответ:* 

Среднее значение некорректно характеризует данные, когда некоторые значения сильно выделяются среди большинства. Пример:

Для чисел [1,2,3,4,5] - медианное и среднее значение будет равно `3`.

Для чисел [1,2,3,4,100] - медианныйм значением останется `3`, а среднее значение уже будет `22`.

Соответственно для расчета средних значений зарплат, возраста или других значений, когда некоторые значения сильно выделяются, лучше воспользоваться медианой.

## Общий вывод.

**Результаты исследований**
- Факт наличия детей у заемщика увеличивает вероятность появления задолжности по возврату кредита примерно на 1.63%. Так же малое влиение имеет количестово детей у заемщика - максимальная разница между группами составляет 1.57%.
- Заемщики живущие в "гражданском браке" или "не женаты / не замужем" имеют большую вероятность получить задолженность по возврату кредита.
- Клиенты с доходом до 30000 чаще имеют задолженность по возврату кредита. Меньше всего заемщики с доходом от 30001 до 50000. Клиенты с доходом от 10000001 и в диапазоне 50001 - 200000 допускают задолжность примерно одинаково.
- Заемщики с целью кредита "операции с автомобилем" и "получение образования" чаще остальных допускают задолжность. Новая гипотеза "Медианный возраст заемщиков с задолжностью по кредиту для образования - до 25 лет включительно." - не подтвердилась. Медианный возраст заемщиков с задолжностью в этой категории примерно равен общему медианному возрасту.

**Исходя из результатов исследования, при построении модели кредитного скоринга, рекомедую больше учитывать следующие факторы:**
- Семейное положение
- Средний доход заемщика
- Цель кредита
